<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Valentine Run</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0b1020; }
    canvas { display:block; margin:0 auto; }
  </style>
</head>
<body>
<script type="module">
import kaboom from "https://cdn.jsdelivr.net/npm/kaboom@3000.1.17/dist/kaboom.mjs";

kaboom({
  background: [11, 16, 32],
  crisp: true, // pixel look
});

                      // Show any crash on the canvas (super helpful on phones / Pages)
                      window.addEventListener("error", (e) => {
                        try {
                          add([
                            rect(width(), height()),
                            pos(0, 0),
                            color(0, 0, 0),
                            opacity(0.85),
                            fixed(),
                          ]);
                          add([
                            text("ERROR:\n" + (e.message || e.error || "Unknown error"), { size: 16, width: width() - 40 }),
                            pos(20, 20),
                            color(255, 120, 120),
                            fixed(),
                          ]);
                        } catch (_) {
                          // if add() isn't available yet, at least log
                        }
                        console.error(e.error || e.message);
                      });

  
// ---------- Sprite generator (no external images needed) ----------
function spriteFromPixels(name, w, h, palette, rows, scale = 4) {
  // rows: array of strings length h, each char maps to palette key (or '.' for transparent)
  const c = document.createElement("canvas");
  c.width = w;
  c.height = h;
  const ctx = c.getContext("2d");
  const img = ctx.createImageData(w, h);

  const setPx = (x, y, rgba) => {
    const i = (y * w + x) * 4;
    img.data[i+0] = rgba[0];
    img.data[i+1] = rgba[1];
    img.data[i+2] = rgba[2];
    img.data[i+3] = rgba[3];
  };

  for (let y = 0; y < h; y++) {
    const row = rows[y];
    for (let x = 0; x < w; x++) {
      const ch = row[x] ?? ".";
      if (ch === ".") {
        setPx(x, y, [0,0,0,0]);
      } else {
        const col = palette[ch];
        setPx(x, y, [col[0], col[1], col[2], 255]);
      }
    }
  }

  ctx.putImageData(img, 0, 0);
  const url = c.toDataURL("image/png");
  return loadSprite(name, url, { sliceX: 1, sliceY: 1 });
}

// ---------- Pixel art sprites ----------
const pal = {
  // skin / outlines
  k: [25, 18, 30],        // outline
  s: [244, 204, 170],     // skin
  b: [200, 150, 120],     // skin shadow
  // hair
  r: [178, 70, 55],       // red hair
  R: [130, 45, 35],       // darker hair
  // eyes
  g: [60, 200, 120],      // green eyes
  d: [20, 20, 25],        // dark eye/line
  // freckles
  f: [165, 95, 75],
  // uniform / clothes
  u: [60, 95, 60],        // army green
  U: [40, 70, 45],        // darker green
  w: [245, 245, 250],     // white shirt
  h: [245, 90, 130],      // heart
  j: [45, 80, 150],       // jeans
  J: [30, 60, 120],       // jeans shadow
  // shoes
  x: [80, 80, 90],
};

// Ethan (16x16): redhead, green eyes, freckles, army uniform vibe
const ethan = [
  "....RRRRRRRR....",
  "...RRrrrrrrRR...",
  "..RRrrrrrrrrRR..",
  "..RrrrRRRRrrrR..",
  "..RrrRssssRrrR..",
  "..RrRssg..sgRr..",
  "..Rrsss.d.dssR..",
  "...rsssffffss...",
  "...rssssssssss..",
  "...RbbssssbbR...",
  "....UuuuuuuU....",
  "...UUUuuuuUUU...",
  "..UUUuuuuuuUUU..",
  "..UUUuuUUuuUUU..",
  "...xx..UU..xx...",
  "....x.......x...",
];

// Celeste (16x16): curly shoulder hair (auburn/brown-red), dark asian eyes, white shirt w/ heart, jeans
// (Using same red palette but more curls/volume around shoulders)
const celeste = [
  "...RRR..RRR.....",
  "..RRrRRRRrRR....",
  ".RRrrRRRRrrRR...",
  ".RrrRrrrrRrrR...",
  ".RrRssssssRrR...",
  ".Rrssd..dssrR...",
  "..rsss....sss...",
  "..rssssssssss...",
  "..RRbbssssbbR...",
  "...w.whwwhww.w...",
  "s..w.hhhhhhw.w..s",
  "...w.whhhhw.w...",
  "...wwwwhhwwww...",
  "...wwwwwwwwww...",
  "...JJjjjjjjJJ...",
  "..JJJjjjjjjJJJ..",
  "...xx......xx...",
  "....x......x....",
];

const p1 = spriteFromPixels("ethan", 16, 16, pal, ethan, 4);
const p2 = spriteFromPixels("celeste", 16, 16, pal, celeste, 4);

Promise.all([p1, p2]).then(() => {
  go("game");
});

// ---------- Game ----------
const SPEED = 260;
const JUMP = 720;
const GRAVITY = 2200;

setGravity(GRAVITY);

function groundY() {
  return height() - 72;
}

scene("game", () => {
  let finished = false;
  let distance = 0;
  const target = 110; // tweak to make shorter/longer

  // Ground
  add([
    rect(width(), 72),
    pos(0, height() - 72),
    area(),
    body({ isStatic: true }),
    color(60, 110, 80),
    "ground",
  ]);

  // Stars
  for (let i = 0; i < 80; i++) {
    add([
      rect(2, 2),
      pos(rand(0, width()), rand(0, height() - 80)),
      color(150, 180, 255),
      opacity(rand(0.2, 0.9)),
    ]);
  }

  // Player: Ethan
  const player = add([
  sprite("ethan"),
  pos(80, groundY() - 16 * 4),
  area({ offset: vec2(10, 10), width: 44, height: 52 }), // simple hitbox
  body(),
  "player",
]);

  // HUD
  const label = add([
    text("Keep running for a surprise!\nJump: Space / Tap\nDistance: 0", { size: 18 }),
    pos(16, 16),
    color(220, 235, 255),
    fixed(),
  ]);

  function doJump() {
    if (player.isGrounded()) player.jump(JUMP);
  }
  onKeyPress("space", doJump);
  onMousePress(doJump);
  onTouchStart(doJump);

  // Obstacles
  function spawnObstacle() {
    if (finished) return;

    const h = choose([24, 32, 40]);
    const w = choose([18, 22, 26]);
    const x = width() + 40;

        add([
      rect(w, h),
      pos(x, groundY() - h),
      area(),
      body({ isStatic: true }),
      color(255, 90, 120),
      move(LEFT, SPEED),
      offscreen({ destroy: true }),
      "obstacle",
    ]);

    wait(rand(0.9, 1.35), spawnObstacle);
  }
  spawnObstacle();

  onUpdate(() => {
    if (finished) return;

    distance += dt() * (SPEED / 30);
    label.text = `Keep running for a surprise!\nJump: Space / Tap\nDistance: ${Math.floor(distance)}`;

    if (distance >= target) {
      finished = true;
      go("poster");
    }
  });

  player.onCollide("obstacle", () => {
    shake(12);
    go("lose", Math.floor(distance));
  });
});

scene("lose", (dist) => {
  add([
    text(`Oof! You bonked.\nDistance: ${dist}\n\nPress Space / Tap to retry`, { size: 28, align: "center" }),
    pos(width() / 2, height() / 2 - 40),
    anchor("center"),
    color(255, 220, 220),
  ]);

  onKeyPress("space", () => go("game"));
  onMousePress(() => go("game"));
  onTouchStart(() => go("game"));
});

// POSTER SCENE
scene("poster", () => {
  add([
    rect(width() - 80, height() - 140),
    pos(40, 70),
    color(245, 240, 255),
    outline(6, rgb(255, 140, 170)),
  ]);

  add([
    text("Baby ðŸ’˜\nWill you be my Valentine?", { size: 44, align: "center" }),
    pos(width() / 2, 120),
    anchor("top"),
    color(60, 20, 40),
  ]);

  // Celeste bigger
  add([
    sprite("celeste"),
    pos(width() / 2, 245),
    scale(5),
    anchor("top"),
  ]);

  add([
    text("Text me with:\n1) SII\n2) CLARO QUE SI MAMI, MWAHH", { size: 26, align: "center" }),
    pos(width() / 2, 430),
    anchor("top"),
    color(80, 40, 70),
  ]);

  // Floating hearts
  for (let i = 0; i < 18; i++) {
    const heart = add([
      text("â¤", { size: rand(18, 36) }),
      pos(rand(0, width()), rand(height(), height() + 300)),
      color(255, 120, 160),
      opacity(rand(0.75, 1)), // your nicer range
      scale(rand(0.9, 1.2)),  // your nicer range
    ]);

    const drift = rand(20, 60);
    const wobble = rand(0.6, 1.2);

    heart.onUpdate(() => {
      heart.pos.y -= dt() * drift;
      heart.pos.x += Math.sin(time() * wobble) * dt() * 30;
      if (heart.pos.y < -40) heart.pos.y = height() + rand(20, 240);
    });
  }


  let canReplay = false;
  wait(3, () => {
    canReplay = true;
  });

  onKeyPress("space", () => { if (canReplay) go("game"); });
  onMousePress(() => { if (canReplay) go("game"); });
  onTouchStart(() => { if (canReplay) go("game"); });
});

</script>
</body>
</html>
